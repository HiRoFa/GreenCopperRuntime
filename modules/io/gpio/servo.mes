import {Assertions as assert} from 'https://raw.githubusercontent.com/HiRoFa/ESsesLib-q/main/modules/utils/assertions.mes';
import {PinSet} from 'greco://gpio';

// todo server should be initialized with a ServoDriver
// ServoDriver (SoftPwmDriver, PwmDriver, I2C?, AbstractDriverBoardDriver, PCA9685ServoDriver extends AbstractDriverBoardDriver, VirtualServoDriver

export class Servo {
    constructor(pinSet, frequency, fullLeftDutyCycle, neutralDutyCycle, fullRightDutyCycle, rangeDegrees, maxRangeMotionSeconds) {

        assert.is_number(frequency, "period should be a positive Number between 0 and 2000");
        assert.is_number(fullLeftDutyCycle, "fullLeftDutyCycle should be a Number between 0 and 100");
        assert.is_number(neutralDutyCycle, "neutralDutyCycle should be a Number between 0 and 100");
        assert.is_number(fullRightDutyCycle, "neutralDutyCycle should be a Number between 0 and 100");
        assert.is_number(rangeDegrees, "rangeDegrees should be a Number between 0 and 360");
        assert.is_number(maxRangeMotionSeconds, "maxRangeMotionSeconds should be a Number between 0 and 10");

        assert.is_lt(frequency, 2001, "frequency should be a Number between 0 and 2000");
        assert.is_gt(frequency, -1, "frequency should be a Number between 0 and 2000");

        assert.is_gt(neutralDutyCycle, -1, "neutralDutyCycle should be a Number between 0 and 100");
        assert.is_lt(neutralDutyCycle, 101, "neutralDutyCycle should be a Number between 0 and 100");

        assert.is_gt(fullLeftDutyCycle, -1, "fullLeftDutyCycle should be a Number between 0 and 100");
        assert.is_lt(fullLeftDutyCycle, neutralDutyCycle, "fullLeftDutyCycle should be a lower Number than neutralDutyCycle");

        assert.is_gt(fullRightDutyCycle, neutralDutyCycle, "fullRightDutyCycle should be a greater Number than neutralDutyCycle");
        assert.is_lt(fullRightDutyCycle, 101, "fullRightDutyCycle should be a Number between 0 and 100");

        assert.is_lt(rangeDegrees, 361, "rangeDegrees should be a Number between 0 and 360");
        assert.is_gt(rangeDegrees, -1, "rangeDegrees should be a Number between 0 and 360");

        assert.is_lt(maxRangeMotionSeconds, 10, "maxRangeMotionSeconds should be a Number between 0 and 10");
        assert.is_gt(maxRangeMotionSeconds, 0, "maxRangeMotionSeconds should be a Number between 0 and 10");

        this.pinSet = pinSet;
        this.frequency = frequency;
        this.fullLeftDutyCycle = fullLeftDutyCycle;
        this.neutralDutyCycle = neutralDutyCycle;
        this.fullRightDutyCycle = fullRightDutyCycle;
        this.rangeDegrees = rangeDegrees;
        this.maxRangeMotionSeconds = maxRangeMotionSeconds;
    }

    /**
    * init a new Servo
    * @param {String} chip name of the gpiochip, defaults to /dev/gpiochip0
    * @param {Number} pinNum
    * @param {Number} frequency the frequency on which the servo operates in Hz, defaults to 50
    * @param {Number} fullLeftDutyCycle the dutyCycle in percentage which may be used to move the servo to it's full left position
    * @param {Number} neutralDutyCycle the dutyCycle in percentage which may be used to move the servo to it's neutral position
    * @param {Number} fullRightDutyCycle the dutyCycle in percentage which may be used to move the servo to it's full right position
    * @param {Number} rangeDegrees the number of degrees the servo can rotate, defaults to 180
    * @param {Number} maxRangeMotionSeconds the number of seconds it takes the servo to move from full left to full right position, this is used to calculate when motion is actually done
    */
    static async init(chip = '/dev/gpiochip0', pinNum = 18, frequency = 50, fullLeftDutyCycle = 5, neutralDutyCycle = 7.5, fullRightDutyCycle = 10, rangeDegrees = 180, maxRangeMotionSeconds = 0.35) {

        let pinSet = new PinSet();
        let instance = new this(pinSet, frequency, fullLeftDutyCycle, neutralDutyCycle, fullRightDutyCycle, rangeDegrees, maxRangeMotionSeconds);

        await instance.pinSet.init(chip, 'out', [pinNum]);

        return instance;

    }

    softPwm(frequency, dutyCycle) {
        console.log("softPwm %s, %s", frequency, dutyCycle);
        this.pinSet.softPwm(frequency, dutyCycle);
    }

    async left() {
        // todo, how to deal with timing, i'd like these methods to resolve when the servo is actually moved. Add a left_to_right_time var? and calc based on that?
        this.softPwm(this.frequency, this.fullLeftDutyCycle);
        // todo calc
        let time = this.maxRangeMotionSeconds * 1000;
        return new Promise((resolve, reject) => {
            setTimeout(resolve, time);
        });
    }

    async right() {
        this.softPwm(this.frequency, this.fullRightDutyCycle);
        // todo calc
        let time = this.maxRangeMotionSeconds * 1000;
        return new Promise((resolve, reject) => {
            setTimeout(resolve, time);
        });
    }

    async neutral() {
        this.softPwm(this.frequency, this.neutralDutyCycle);
        // todo calc
        let time = this.maxRangeMotionSeconds * 1000;
        return new Promise((resolve, reject) => {
            setTimeout(resolve, time);
        });
    }

    /**
    * move the servo to a certain angle
    * @param {Number} degrees where neutral = 0 and left is a negative number and right is a positive number
    */
    async degrees(degrees = 0) {

    }

    async off(){
        console.log("softPwmOff");
        return this.pinSet.softPwmOff();
    }
}