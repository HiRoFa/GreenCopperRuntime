searchState.loadedDescShard("swc_ecma_utils", 0, "Finds all <strong>binding</strong> idents of variables.\nExtension methods for Expr.\nExtension methods for Expr.\nFinds usage of <code>ident</code>\nMay have some side effects.\nDoes not have any side effect.\nVariable remapper\nType of value.\nNot determined at compile time.`\nNot determined at compile time.`\nRuntime value.\nUsed to determine super_class_ident\nReturns <code>(ident, aliased)</code>\nCreates an ExprOrSpread using the given Expr.\nCreates an ExprOrSpread using the given Expr.\nGet bool value of <code>self</code> if it does not have any side …\nEmulates javascript Number() cast function.\nReturns Known only if it’s pure.\nThis method emulates the <code>Boolean()</code> JavaScript cast …\nCollects binding identifiers.\nCollects binding identifiers, but only if it has a context …\nThis does not recurse into a function if <code>this</code> is changed …\nAdd side effects of <code>expr</code> to <code>to</code>. This function preserves …\nExtracts hoisted variables\nExtracts hoisted variables\nFinds all <strong>binding</strong> idents of <code>node</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nApply the supplied predicate against all possible result …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncreate a ArrowExpr which return self\ncreate a ArrowExpr which return self\ncreate a Function which return self\ncreate a Function which return self\nCreates a statement whcih return <code>self</code>.\nCreates a statement whcih return <code>self</code>.\nCreates an expression statement with <code>self</code>.\nCreates an expression statement with <code>self</code>.\ncreate a var declartor using self as init\ncreate a var declartor using self as init\nReturns <code>true</code> if <code>id</code> references a global object.\nReturns true if this is an immutable value.\nReturns true if the value is known.\nChecks if <code>self</code> is <code>NaN</code>.\nReturns <code>true</code> if <code>id</code> references a global object.\nReturns true if it’s pure.\nCheck if <code>e</code> is <code>...arguments</code>\nReturns true if the value is not known.\nTrue for argument of <code>typeof</code>.\nCreates a assign expr <code>$lhs $op $self</code>\nCreates a assign expr <code>$lhs $op $self</code>\nCreates a binary expr <code>$self $op $rhs</code>\nCreates a binary expr <code>$self $op $rhs</code>\nCreates a binary expr <code>$self === </code>\nCreates a binary expr <code>$self === </code>\nCreates a member expression.\nModule for parallel processing\ninject <code>branch</code> after directives\ninject <code>stmts</code> after directives\nmake a new expression which evaluates <code>val</code> preserving side …\nShortcut for …\nSimilar to <code>prop_name_to_expr</code>, but used for value position.\nReplace all <code>from</code> in <code>expr</code> with <code>to</code>.\nstmts contain top level return/break/continue/throw\nCast to javascript’s int32\nCreates <code>void 0</code>.\nThis SyntaxContext should be applied only to unresolved …\nDon’t recurse into constructor\nDon’t recurse into constructor\nNo-op (we don’t care about expressions)\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nDon’t recurse into fn\nNo-op (we don’t care about expressions)\nDon’t recurse into fn\nDon’t use it against function, it will stop if come …\nThe result of declaration wrapper includes two parts. …\nDisable hoisting of <code>arguments</code>\nDisable hoisting of nodes realted to <code>super</code>\nDisable hoisting of <code>this</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nIf a function has a function name, it may be called …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDon’t recurse into constructor\nDon’t recurse into fn\nDon’t recurse into getter/setter/method except computed …\nThis is considered as a private type and it’s NOT A …\nInvoked after visiting all ModuleItems, possibly in …\nInvoked after visiting all Stmts, possibly in parallel.\nUsed to create visitor.\nInvoke <code>op</code> in parallel, if <code>swc_ecma_utils</code> is compiled with …\nInvoke <code>op</code> in parallel, if <code>swc_ecma_utils</code> is compiled with …\nThis can be called in anytime.\nThis collects variables bindings while ignoring if it’s …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")