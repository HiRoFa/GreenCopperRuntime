searchState.loadedDescShard("num_bigint_dig", 0, "A Big integer (signed version: <code>BigInt</code>, unsigned version: …\nA big signed integer type.\nA big unsigned integer type.\nA generic trait for converting a value to a <code>BigInt</code>, …\nA generic trait for converting a value to a <code>BigUint</code>, and …\nA generic trait for generating random primes.\nA random distribution for <code>BigUint</code> and <code>BigInt</code> values of a …\nA Sign is a <code>BigInt</code>’s composing element.\nA generic trait for converting a value to a <code>BigInt</code>.\nA generic trait for converting a value to a <code>BigUint</code>.\nThe back-end implementing rand’s <code>UniformSampler</code> for …\nThe back-end implementing rand’s <code>UniformSampler</code> for …\nReinitializes a <code>BigInt</code>.\nReinitializes a <code>BigInt</code>, using native <code>BigDigit</code>s.\nAssign a value to a <code>BigUint</code>.\nReturns the ceil value of the average of <code>self</code> and <code>other</code>.\nReturns the ceil value of the average of <code>self</code> and <code>other</code>.\nReturns the floor value of the average of <code>self</code> and <code>other</code>.\nReturns the floor value of the average of <code>self</code> and <code>other</code>.\nDetermines the fewest bits necessary to express the <code>BigInt</code>,\nDetermines the fewest bits necessary to express the <code>BigUint</code>…\nReturns the truncated principal cube root of <code>self</code> – see …\nReturns the truncated principal cube root of <code>self</code> – see …\nDeprecated, use <code>is_multiple_of</code> instead.\nDeprecated, use <code>is_multiple_of</code> instead.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates and initializes a <code>BigInt</code>.\nCreates and initializes a <code>BigInt</code>.\nCreates and initializes a <code>BigUint</code>.\nCreates and initializes a <code>BigInt</code>.\nCreates and initializes a <code>BigUint</code>.\nCreates and initializes a <code>BigInt</code>. Each u8 of the input …\nCreates and initializes a <code>BigUint</code>. Each u8 of the input …\nCreates and initializes a <code>BigInt</code>. Each u8 of the input …\nCreates and initializes a <code>BigUint</code>. Each u8 of the input …\nCreates and initializes a <code>BigInt</code> from an array of bytes in …\nCreates and initializes a <code>BigInt</code> from an array of bytes in …\nCreates and initializes a <code>BigInt</code>.\nCreates and initializes a <code>BigUint</code>.\nCreates and initializes a <code>BigInt</code> using <code>BigDigit</code>s.\nCreates and initializes a <code>BigUint</code>.\nCreates and initializes a BigInt.\nCreates and initializes a <code>BigUint</code>.\nCalculates the Greatest Common Divisor (GCD) of the number …\nCalculates the Greatest Common Divisor (GCD) of the number …\nGenerate a random BigInt of the given bit size.\nGenerate a random <code>BigInt</code> within the given range. The lower …\nGenerate a random <code>BigUint</code> of the given bit size.\nGenerate a random <code>BigUint</code> less than the given bound. Fails …\nGenerate a random <code>BigUint</code> within the given range. The lower\nGenerate a random prime number with as many bits as given.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts the value of <code>self</code> to a <code>BigInt</code>.\nConverts the value of <code>self</code> to a <code>BigUint</code>.\nReturns <code>true</code> if the number is divisible by <code>2</code>.\nReturns <code>true</code> if the number is divisible by <code>2</code>.\nReturns <code>true</code> if the number is a multiple of <code>other</code>.\nReturns <code>true</code> if the number is a multiple of <code>other</code>.\nReturns <code>true</code> if the number is not divisible by <code>2</code>.\nReturns <code>true</code> if the number is not divisible by <code>2</code>.\nCalculates the Lowest Common Multiple (LCM) of the number …\nCalculates the Lowest Common Multiple (LCM) of the number …\nReturns <code>(self ^ exponent) mod modulus</code>\nReturns <code>(self ^ exponent) % modulus</code>.\nNegate Sign value.\nNegates the sign of BigInt.\nCreates and initializes a BigInt.\nCreates and initializes a <code>BigUint</code>.\nCreates and initializes a <code>BigUint</code>.\nReturns the truncated principal <code>n</code>th root of <code>self</code> – See …\nReturns the truncated principal <code>n</code>th root of <code>self</code> – see …\nCreates and initializes a <code>BigInt</code>.\nCreates and initializes a <code>BigUint</code>. The input slice must …\nImplements probabilistic prime checkers.\nSets the value to the provided digit, reusing internal …\nReturns the sign of the <code>BigInt</code> as a <code>Sign</code>.\nReturns the truncated principal square root of <code>self</code> – …\nReturns the truncated principal square root of <code>self</code> – …\nConverts the value of <code>self</code> to a <code>BigInt</code>.\nConverts the value of <code>self</code> to a <code>BigUint</code>.\nConverts this <code>BigInt</code> into a <code>BigUint</code>, if it’s not …\nReturns the sign and the byte representation of the <code>BigInt</code> …\nReturns the byte representation of the <code>BigUint</code> in …\nReturns the sign and the byte representation of the <code>BigInt</code> …\nReturns the byte representation of the <code>BigUint</code> in …\nReturns the integer in the requested base in big-endian …\nReturns the integer in the requested base in big-endian …\nReturns the integer in the requested base in little-endian …\nReturns the integer in the requested base in little-endian …\nReturns the two’s complement byte representation of the …\nReturns the two’s complement byte representation of the …\nReturns the integer formatted as a string in the given …\nReturns the integer formatted as a string in the given …\n/Two argument addition of raw slices: a += b\nDivide a two digit numerator by a one digit divisor, …\nUses the lehemer algorithm. Based on …\nFind last set bit fls(0) == 0, fls(u32::MAX) == 32\nDivide two integers, and ceil the result.\nJacobi returns the Jacobi symbol (x/y), either +1, -1, or …\nThree argument multiply accumulate: acc += b * c\nThree argument multiply accumulate: acc += b * c\nCalculate the modular inverse of <code>g</code>. Implementation is …\nSubtract with borrow:\nXGCD sets z to the greatest common divisor of a and b and …\nCalculate the next larger prime, given a starting number <code>n</code>.\nProbablyPrime reports whether x is probably prime, …\nReports whether n passes the “almost extra strong” …\nReports whether n passes reps rounds of the Miller-Rabin …\nGeneric trait to implement extended GCD. Calculates the …\nGeneric trait to implement modular inverse.\nFunction to calculate the modular multiplicative inverse …")