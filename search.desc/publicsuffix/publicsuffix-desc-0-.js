searchState.loadedDescShard("publicsuffix", 0, "A native Rust library for Mozilla’s Public Suffix List\nA registrable domain name\nErrors returned by this crate\nA list of only ICANN suffixes\nInformation about the suffix\nThe official URL of the list\nA dynamic public suffix list\nA list of only private suffixes\nA list of all public suffixes\nThe suffix of a domain name\nType of suffix\nThe suffix as bytes\nThe domain name as bytes\nGet the registrable domain\nFinds the suffix information of the given input labels\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a new list from a byte slice\nCreates a new list from a byte slice\nCreates a new list from a byte slice\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks to see if the list is empty, ignoring the wildcard …\nChecks to see if the list is empty, ignoring the wildcard …\nChecks to see if the list is empty, ignoring the wildcard …\nWhether or not the suffix is fully qualified (i.e. it ends …\nWhether or not this is a known suffix (i.e. it is …\nCreates a new list with default wildcard rule support\nGet the public suffix of the domain\nThe public suffix of this domain name\nReturns the suffix with a trailing <code>.</code> removed\nReturns the domain with a trailing <code>.</code> removed\nWhether this is an <code>ICANN</code>, <code>private</code> or unknown suffix")