searchState.loadedDescShard("lexical_core", 0, "Fast lexical conversion routines for a no_std environment.\nMaximum number of bytes required to serialize any number …\nEmpty byte array found.\nEmpty exponent found.\nEmpty fraction found.\nEmpty integer found.\nEmpty mantissa found.\nContains the error value\nError code during parsing, indicating failure type.\nExponent was present without fraction component.\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nTrait for numerical types that can be parsed from bytes.\nTrait for numerical types that can be parsed from bytes …\nShort infinity string is too long.\nLong infinity string is too long.\nLong infinity string is too short: it must be as long as …\nInvalid character for a base prefix.\nInvalid character for a base suffix.\nInvalid consecutive exponent digit separator.\nInvalid consecutive fraction digit separator.\nInvalid consecutive integer digit separator.\nInvalid decimal point character.\nInvalid digit found before string termination.\nInvalid digit separator character.\nExponent was present but not allowed.\nInvalid base for the exponent.\nOptional exponent flags were set while disabling exponent …\nInvalid radix for the exponent digits.\nSet no positive exponent sign while requiring exponent …\nInvalid symbol to represent exponent notation.\nInvalid flags were set without the format feature.\nInvalid float parsing algorithm.\nInvalid precision flags for writing floats.\nInvalid short infinity string: must start with an <code>i</code> …\nInvalid long infinity string: must start with an <code>i</code> …\nInteger or integer component of float had invalid leading …\nInvalid radix for the mantissa (significant) digits.\nSet no positive mantissa sign while requiring mantissa …\nInvalid NaN string: must start with an <code>n</code> character.\nInvalid negative exponent break: break is above 0.\nInvalid negative sign for an unsigned type was found.\nInvalid positive exponent break: break is below 0.\nInvalid positive exponent sign was found.\nInvalid positive mantissa sign was found.\nInvalid positive sign for an integer was found.\nInvalid punctuation characters: multiple symbols overlap.\nInvalid radix for the significant digits.\nSet optional special float flags while disable special …\nNo exponent with required exponent notation.\nExponent sign was required(usize), but not found.\nMantissa sign was required(usize), but not found.\nIntegral sign was required(usize), but not found.\nNaN string is too long.\nBuild number format from specifications.\nContains the success value\nCustom formatting options for parsing a number.\nCustom formatting options for writing a number.\nIntegral overflow occurred during numeric parsing.\nOptions to customize parsing floats.\nBuilder for <code>Options</code>.\nImmutable options to customize writing integers.\nBuilder for <code>Options</code>.\nShared trait for all parser options.\nA specialized Result type for lexical operations.\nAn error did not actually occur, and the result was …\nTrait for numerical types that can be serialized to bytes.\nTrait for numerical types that can be serialized to bytes …\nIntegral underflow occurred during numeric parsing.\nOptions to customize writing floats.\nBuilder for <code>Options</code>.\nImmutable options to customize writing integers.\nBuilder for <code>Options</code>.\nShared trait for all writer options.\nCreate number format for standard, binary number.\nGet an upper bound on the buffer size.\nBuild the Options struct.\nBuild the Options struct.\nCreate 128-bit, packed number format struct from builder …\nBuild the Options struct.\nBuild the Options struct.\nBuild the Options struct with bounds validation.\nBuild the Options struct with bounds validation.\nBuild the Options struct with bounds validation.\nBuild the Options struct without validation.\nGet OptionsBuilder as a static function.\nGet OptionsBuilder as a static function.\nGet WriteFloatOptionsBuilder as a static function.\nGet OptionsBuilder as a static function.\nCreate number format for standard, decimal number.\nSet the character to separate the integer from the …\nGet the character to separate the integer from the …\nSet the character to separate the integer from the …\nGet the character to separate the integer from the …\nSet the character to designate the exponent component of a …\nGet the character to designate the exponent component of a …\nSet the character to designate the exponent component of a …\nGet the character to designate the exponent component of a …\nSet the radix for the exponent.\nSet the radix for exponent digits.\nPublic API for the number format packed struct.\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nChecked parser for a string-to-number conversion.\nChecked parser for a string-to-number conversion.\nChecked parser for a string-to-number conversion.\nChecked parser for a string-to-number conversion.\nCreate number format from radix.\nCreate the default options for a given radix.\nCreate the default options for a given radix.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the character to separate the integer from the …\nGet the character to separate the integer from the …\nGet the digit separator for the number format.\nGet the character to designate the exponent component of a …\nGet the character to designate the exponent component of a …\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet the short string representation for <code>Infinity</code>.\nGet the short string representation for <code>Infinity</code>.\nGet the long string representation for <code>Infinity</code>.\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet if we disable the use of arbitrary-precision …\nGet the radix for mantissa digits.\nGet the maximum number of significant digits to write.\nGet the minimum number of significant digits to write.\nGet the string representation for <code>NaN</code>.\nGet the string representation for <code>NaN</code>.\nGet the minimum exponent prior to using scientific …\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet the maximum exponent prior to using scientific …\nGet if digits are required after the exponent character.\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet the rounding mode for writing digits with precision …\nGet if any digit separators are allowed in special …\nGet if we should trim a trailing <code>&quot;.0&quot;</code> from floats.\nCreate number format for standard, hexadecimal number.\nGet the index for the parsing error.\nDetermine if <code>inf_str</code> is valid.\nDetermine if <code>inf_str</code> is valid.\nSet the string representation for <code>Infinity</code>.\nGet the short string representation for <code>Infinity</code>.\nSet the short string representation for <code>Infinity</code>.\nGet the short string representation for <code>Infinity</code>.\nSet the long string representation for <code>Infinity</code>.\nGet the long string representation for <code>Infinity</code>.\nDetermine if <code>infinity_string</code> is valid.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nDetermine if the options are valid.\nDetermine if the options are valid.\nCheck if the builder state is valid.\nCheck if the options state is valid.\nCheck if the builder state is valid.\nCheck if the options state is valid.\nCheck if the builder state is valid.\nCheck if the options state is valid.\nCheck if the builder state is valid.\nCheck if the options state is valid.\nSet if we disable the use of arbitrary-precision …\nGet if we disable the use of arbitrary-precision …\nSet the radix for mantissa digits.\nSet the maximum number of significant digits to write.\nGet the maximum number of significant digits to write.\nSet the minimum number of significant digits to write.\nGet the minimum number of significant digits to write.\nDetermine if <code>nan_str</code> is valid.\nDetermine if <code>nan_str</code> is valid.\nSet the string representation for <code>NaN</code>.\nGet the string representation for <code>NaN</code>.\nSet the string representation for <code>NaN</code>.\nGet the string representation for <code>NaN</code>.\nSet the minimum exponent prior to using scientific …\nGet the minimum exponent prior to using scientific …\nCreate new options builder with default options.\nCreate options with default values.\nCreate new options builder with default options.\nCreate options with default values.\nCreate new NumberFormatBuilder with default arguments.\nCreate options with default values.\nCreate new options builder with default options.\nCreate options with default values.\nCreate number format for standard, octal number.\nParse complete number from string.\nConfiguration options for parsing floats.\nConfiguration options for parsing integers.\nParse partial number from string.\nParse partial number from string with custom parsing …\nParse complete number from string with custom parsing …\nSet the maximum exponent prior to using scientific …\nGet the maximum exponent prior to using scientific …\nAlias for mantissa radix.\nCreate OptionsBuilder using existing values.\nCreate OptionsBuilder using existing values.\nRe-create builder from format.\nCreate OptionsBuilder using existing values.\nCreate OptionsBuilder using existing values.\nSet the rounding mode for writing digits with precision …\nGet the rounding mode for writing digits with precision …\nSet the character to separate the integer from the …\nSet the character to separate the integer from the …\nSet the character to designate the exponent component of a …\nSet the character to designate the exponent component of a …\nSet the short string representation for <code>Infinity</code> Unsafe, …\nSet the short string representation for <code>Infinity</code> Unsafe, …\nSet the long string representation for <code>Infinity</code> Unsafe, …\nSet if we disable the use of arbitrary-precision …\nSet the maximum number of significant digits to write. …\nSet the minimum number of significant digits to write. …\nSet the string representation for <code>NaN</code>. Unsafe, use the …\nSet the string representation for <code>NaN</code>. Unsafe, use the …\nSet the minimum exponent prior to using scientific …\nSet the maximum exponent prior to using scientific …\nSet the rounding mode for writing digits with precision …\nSet if we should trim a trailing <code>&quot;.0&quot;</code> from floats. Unsafe, …\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSerializer for a number-to-string conversion.\nSet if we should trim a trailing <code>&quot;.0&quot;</code> from floats.\nGet if we should trim a trailing <code>&quot;.0&quot;</code> from floats.\nWrite number to string.\nConfiguration options for writing floats.\nConfiguration options for writing integers.\nWrite number to string, without bounds checking the buffer.\nWrite number to string with custom options.\nWrite number to string with custom options.\nMask to extract the base prefix character.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nShift to convert to and from a base suffix as a <code>u8</code>.\nBase prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nExponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nMultiple consecutive digit separators are allowed.\nMask to extract the digit separator character.\nShift to convert to and from a digit separator as a <code>u8</code>.\nMask to extract the exponent base: the base the exponent …\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nDigit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nMultiple consecutive fraction digit separators are allowed.\nDigit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nA digit separator is allowed after any fraction digits.\nMultiple consecutive integer digit separators are allowed.\nDigit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nA digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nExponent notation is not allowed.\nExponent without a fraction component is not allowed.\nLeading zeros before a float value are not allowed.\nLeading zeros before an integer value are not allowed.\nPositive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nNo value.\nBuild number format from specifications.\nType with the exact same size as a <code>u8</code>.\nAlias for MANTISSA_RADIX.\nAlias for MANTISSA_RADIX_SHIFT.\nAt least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nExponent notation is required.\nPositive sign before the exponent is required.\nDigits are required after the decimal point. This check …\nDigits are required before the decimal point.\nMantissa digits are required (either before or after the …\nPositive sign before the mantissa is required.\nAny digit separators are allowed in special (non-finite) …\nStandard number format. This is identical to the Rust …\nSome value of type <code>T</code>.\nA digit separator is allowed after any digits.\nExtract the base prefix character from the format packed …\nExtract the base suffix character from the format packed …\nExtract the digit separator from the format packed struct.\nExtract the exponent base from the format packed struct. …\nExtract the exponent radix from the format packed struct. …\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid. Digit …\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters for …\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nExtract the mantissa radix from the format packed struct.\nExtract a generic radix from the format and bitflags.\nNumerical format where <code>^</code> is used as the exponent notation …\nNumber format for a Clojure literal floating-point number.\nNumber format to parse a Clojure float from string.\nNumber format for a COBOL literal floating-point number.\nNumber format to parse a COBOL float from string.\nNumber format for a Coffeescript literal floating-point …\nNumber format to parse a Coffeescript float from string.\nNumber format for a C# literal floating-point number.\nNumber format to parse a C# float from string.\nNumber format for a C++ literal floating-point number.\nNumber format for a C literal floating-point number.\nNumerical format with a decimal comma. This is the …\nNumber format for a D literal floating-point number.\nNumber format for an Elixir literal floating-point number.\nNumber format to parse an Elixir float from string.\nNumber format for an Elm literal floating-point number.\nNumber format to parse an Elm float from string.\nNumber format for an Erlang literal floating-point number.\nNumber format to parse an Erlang float from string.\nNumber format for a FORTRAN literal floating-point number.\nNumber format for an F# literal floating-point number.\nNumber format for a Gambit-C literal floating-point number.\nNumber format to parse a Gambit-C float from string.\nNumber format for a Go literal floating-point number.\nNumber format for a Guile literal floating-point number.\nNumber format to parse a Guile float from string.\nNumber format for a Haskell literal floating-point number.\nNumber format to parse a Haskell float from string.\nNumerical format for hexadecimal floats, which use a <code>p</code> …\nNumber format for a Javascript literal floating-point …\nNumber format to parse a Javascript float from string.\nNumber format for a Java literal floating-point number.\nNumber format to parse a Java float from string.\nNumber format for a JSON literal floating-point number.\nNumber format for a Julia literal floating-point number.\nNumber format for a Kawa literal floating-point number.\nNumber format to parse a Kawa float from string.\nNumber format for a Kotlin literal floating-point number.\nNumber format to parse a Kotlin float from string.\nNumber format for a MATLAB literal floating-point number.\nNumber format for a MongoDB literal floating-point number.\nNumber format for a MySQL literal floating-point number.\nNumber format for an Objective-C literal floating-point …\nNumber format to parse an Objective-C float from string.\nNumber format for an OCaml literal floating-point number.\nOptions to customize parsing floats.\nBuilder for <code>Options</code>.\nNumber format for a Perl literal floating-point number.\nNumber format for a PHP literal floating-point number.\nNumber format for a PostgreSQL literal floating-point …\nNumber format for a Python literal floating-point number.\nNumber format for an ReasonML literal floating-point …\nNumber format for a Ruby literal floating-point number.\nNumber format to parse a Ruby float from string.\nNumber format for a Rust literal floating-point number.\nNumber format for an R literal floating-point number.\nNumber format for a Safe literal floating-point number.\nNumber format for a Scala literal floating-point number.\nNumber format to parse a Scala float from string.\nNumber format for a SQLite literal floating-point number.\nStandard number format.\nNumber format for a Swift literal floating-point number.\nNumber format for a TOML literal floating-point number.\nNumber format for a Visual Basic literal floating-point …\nNumber format to parse a Visual Basic float from string.\nNumber format for an XML literal floating-point number.\nNumber format for a YAML literal floating-point number.\nNumber format for a Zig literal floating-point number.\nImmutable options to customize writing integers.\nBuilder for <code>Options</code>.\nStandard number format.\nNumerical format where <code>^</code> is used as the exponent notation …\nNumber format for a Clojure literal floating-point number.\nNumber format to parse a Clojure float from string.\nNumber format for a COBOL literal floating-point number.\nNumber format to parse a COBOL float from string.\nNumber format for a Coffeescript literal floating-point …\nNumber format to parse a Coffeescript float from string.\nNumber format for a C# literal floating-point number.\nNumber format to parse a C# float from string.\nNumber format for a C++ literal floating-point number.\nNumber format for a C literal floating-point number.\nNumerical format with a decimal comma. This is the …\nNumber format for a D literal floating-point number.\nNumber format for an Elixir literal floating-point number.\nNumber format to parse an Elixir float from string.\nNumber format for an Elm literal floating-point number.\nNumber format to parse an Elm float from string.\nNumber format for an Erlang literal floating-point number.\nNumber format to parse an Erlang float from string.\nNumber format for a FORTRAN literal floating-point number.\nNumber format for an F# literal floating-point number.\nNumber format for a Gambit-C literal floating-point number.\nNumber format to parse a Gambit-C float from string.\nNumber format for a Go literal floating-point number.\nNumber format for a Guile literal floating-point number.\nNumber format to parse a Guile float from string.\nNumber format for a Haskell literal floating-point number.\nNumber format to parse a Haskell float from string.\nNumerical format for hexadecimal floats, which use a <code>p</code> …\nNumber format for a Javascript literal floating-point …\nNumber format to parse a Javascript float from string.\nNumber format for a Java literal floating-point number.\nNumber format to parse a Java float from string.\nNumber format for a JSON literal floating-point number.\nNumber format for a Julia literal floating-point number.\nNumber format for a Kawa literal floating-point number.\nNumber format to parse a Kawa float from string.\nNumber format for a Kotlin literal floating-point number.\nNumber format to parse a Kotlin float from string.\nNumber format for a MATLAB literal floating-point number.\nNumber format for a MongoDB literal floating-point number.\nNumber format for a MySQL literal floating-point number.\nNo value.\nNo value.\nNumber format for an Objective-C literal floating-point …\nNumber format to parse an Objective-C float from string.\nNumber format for an OCaml literal floating-point number.\nType with the exact same size as a <code>i32</code>.\nType with the exact same size as a <code>usize</code>.\nOptions to customize writing floats.\nBuilder for <code>Options</code>.\nNumber format for a Perl literal floating-point number.\nNumber format for a PHP literal floating-point number.\nNumber format for a PostgreSQL literal floating-point …\nNumber format for a Python literal floating-point number.\nNumber format for an ReasonML literal floating-point …\nNumber format for a Ruby literal floating-point number.\nNumber format to parse a Ruby float from string.\nNumber format for a Rust literal floating-point number.\nNumber format for an R literal floating-point number.\nRound to the nearest float string with the given number of …\nEnumeration for how to round floats with precision control.\nNumber format for a Safe literal floating-point number.\nNumber format for a Scala literal floating-point number.\nNumber format to parse a Scala float from string.\nNumber format for a SQLite literal floating-point number.\nStandard number format.\nNumber format for a Swift literal floating-point number.\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nNumber format for a TOML literal floating-point number.\nTruncate the float string with the given number of …\nNumber format for a Visual Basic literal floating-point …\nNumber format to parse a Visual Basic float from string.\nNumber format for an XML literal floating-point number.\nNumber format for a YAML literal floating-point number.\nNumber format for a Zig literal floating-point number.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nDetermine if we should round down.\nImmutable options to customize writing integers.\nBuilder for <code>Options</code>.\nStandard number format.")