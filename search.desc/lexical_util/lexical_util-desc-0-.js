searchState.loadedDescShard("lexical_util", 0, "Shared utilities for lexical conversion routines.\nSimple, shared algorithms for slices and iterators.\nUtilities for working with ASCII characters.\nDebugging assertions to check a radix is valid.\nPre-defined constants for numeric types.\nUtilities to process digits.\nOptimized division algorithms for u128.\nError type for numeric parsing functions.\nExtended precision floating-point type.\nPublic API for the number format packed struct.\nDefine FromLexical trait.\nDefine FromLexicalWithOptions trait.\nSpecialized iterator traits.\nFast multiplication routines.\nUtilities for Rust numbers.\nShared traits for the options API.\nResult type for numeric parsing functions.\nThe maximum digits that can be held in a u64 for a given …\nDefine ToLexical trait.\nDefine ToLexicalWithOptions trait.\nCopy bytes from source to destination.\nCount the number of leading characters equal to a given …\nCount the number of trailing characters equal to a given …\nTrim character from the end (right-side) of a slice.\nDetermine if a character is a valid ASCII character for …\nDetermine if a slice is all valid ASCII characters for …\nDetermine if a character is a valid ASCII letter.\nDetermine if a slice is all valid ASCII letters. Modified …\nAssertion the buffer has sufficient room for the output.\nCheck radix is is 10 or a power of 2.\nDebug assertion the buffer has sufficient room for the …\nCheck radix is is 10 or a power of 2.\nMaximum number of bytes required to serialize any number …\nMaximum number of bytes required to serialize a number to …\nMaximum number of bytes required to serialize a number to …\nThe size, in bytes, of formatted values.\nDetermine if a character is a digit.\nDetermine if a character is a digit with a radix known at …\nConvert a character to a digit.\nConvert a character to a digit with a radix known at …\nUnchecked, highly optimized algorithm to convert a char to …\nConvert a digit to a character. This uses a pre-computed …\nConvert a digit to a character with a radix known at …\nFast division/remainder algorithm for u128, without a fast …\nFast division/remainder algorithm for u128, without a fast …\nCalculate a div/remainder algorithm optimized for …\nOptimized fallback division/remainder algorithm for u128.\nCalculate the div/remainder of a value based on the radix.\nEmpty byte array found.\nEmpty exponent found.\nEmpty fraction found.\nEmpty integer found.\nEmpty mantissa found.\nError code during parsing, indicating failure type.\nExponent was present without fraction component.\nShort infinity string is too long.\nLong infinity string is too long.\nLong infinity string is too short: it must be as long as …\nInvalid character for a base prefix.\nInvalid character for a base suffix.\nInvalid consecutive exponent digit separator.\nInvalid consecutive fraction digit separator.\nInvalid consecutive integer digit separator.\nInvalid decimal point character.\nInvalid digit found before string termination.\nInvalid digit separator character.\nExponent was present but not allowed.\nInvalid base for the exponent.\nOptional exponent flags were set while disabling exponent …\nInvalid radix for the exponent digits.\nSet no positive exponent sign while requiring exponent …\nInvalid symbol to represent exponent notation.\nInvalid flags were set without the format feature.\nInvalid float parsing algorithm.\nInvalid precision flags for writing floats.\nInvalid short infinity string: must start with an <code>i</code> …\nInvalid long infinity string: must start with an <code>i</code> …\nInteger or integer component of float had invalid leading …\nInvalid radix for the mantissa (significant) digits.\nSet no positive mantissa sign while requiring mantissa …\nInvalid NaN string: must start with an <code>n</code> character.\nInvalid negative exponent break: break is above 0.\nInvalid negative sign for an unsigned type was found.\nInvalid positive exponent break: break is below 0.\nInvalid positive exponent sign was found.\nInvalid positive mantissa sign was found.\nInvalid positive sign for an integer was found.\nInvalid punctuation characters: multiple symbols overlap.\nInvalid radix for the significant digits.\nSet optional special float flags while disable special …\nNo exponent with required exponent notation.\nExponent sign was required(usize), but not found.\nMantissa sign was required(usize), but not found.\nIntegral sign was required(usize), but not found.\nNaN string is too long.\nIntegral overflow occurred during numeric parsing.\nAn error did not actually occur, and the result was …\nIntegral underflow occurred during numeric parsing.\nReturns the argument unchanged.\nGet the index for the parsing error.\nCalls <code>U::from(self)</code>.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nconst fn check to see if an error is of a specific type.\nExtended precision floating-point type.\nBinary exponent for the extended-precision float.\nGet the exponent component.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMantissa for the extended-precision float.\nGet the mantissa component.\nMask to extract the base prefix character.\nShift to convert to and from a base prefix as a <code>u8</code>.\nMask to extract the base suffix character.\nShift to convert to and from a base suffix as a <code>u8</code>.\nBase prefixes are case-sensitive.\nBase suffixes are case-sensitive.\nExponent characters are case-sensitive.\nSpecial (non-finite) values are case-sensitive.\nMultiple consecutive digit separators are allowed.\nMask to extract the digit separator character.\nShift to convert to and from a digit separator as a <code>u8</code>.\nMask to extract the exponent base: the base the exponent …\nShift to convert to and from an exponent base as a <code>u32</code>.\nMultiple consecutive exponent digit separators are allowed.\nDigit separators are allowed between exponent digits.\nA digit separator is allowed before any exponent digits.\nMask to extract the exponent radix: the radix for the …\nShift to convert to and from an exponent radix as a <code>u32</code>.\nA digit separator is allowed after any exponent digits.\nMultiple consecutive fraction digit separators are allowed.\nDigit separators are allowed between fraction digits.\nA digit separator is allowed before any fraction digits.\nA digit separator is allowed after any fraction digits.\nMultiple consecutive integer digit separators are allowed.\nDigit separators are allowed between integer digits.\nA digit separator is allowed before any integer digits.\nA digit separator is allowed after any integer digits.\nDigit separators are allowed between digits.\nA digit separator is allowed before any digits.\nMask to extract the mantissa radix: the radix for the …\nShift to convert to and from a mantissa radix as a <code>u32</code>.\nExponent notation is not allowed.\nExponent without a fraction component is not allowed.\nLeading zeros before a float value are not allowed.\nLeading zeros before an integer value are not allowed.\nPositive sign before the exponent is not allowed.\nPositive sign before the mantissa is not allowed.\nSpecial (non-finite) values are not allowed.\nNo value.\nBuild number format from specifications.\nType with the exact same size as a <code>u8</code>.\nAlias for MANTISSA_RADIX.\nAlias for MANTISSA_RADIX_SHIFT.\nAt least 1 digit in the number is required.\nDigits are required after the exponent character. This …\nExponent notation is required.\nPositive sign before the exponent is required.\nDigits are required after the decimal point. This check …\nDigits are required before the decimal point.\nMantissa digits are required (either before or after the …\nPositive sign before the mantissa is required.\nAny digit separators are allowed in special (non-finite) …\nStandard number format. This is identical to the Rust …\nSome value of type <code>T</code>.\nA digit separator is allowed after any digits.\nExtract the base prefix character from the format packed …\nExtract the base suffix character from the format packed …\nCreate number format for standard, binary number.\nCreate 128-bit, packed number format struct from builder …\nCreate number format for standard, decimal number.\nExtract the digit separator from the format packed struct.\nExtract the exponent base from the format packed struct. …\nSet the radix for the exponent.\nExtract the exponent radix from the format packed struct. …\nSet the radix for exponent digits.\nGet the error type from the format packed struct.\nDetermine if the format packed struct is valid.\nReturns the argument unchanged.\nCreate number format from radix.\nGet the optional character for the base prefix.\nGet the optional character for the base suffix.\nGet if base prefixes are case-sensitive.\nGet if base suffixes are case-sensitive.\nGet if exponent characters are case-sensitive.\nGet if special (non-finite) values are case-sensitive.\nGet the digit separator for the number format.\nGet the radix for the exponent.\nGet if multiple consecutive exponent digit separators are …\nGet if digit separators are allowed between exponent …\nGet if a digit separator is allowed before any exponent …\nGet the radix for exponent digits.\nGet if a digit separator is allowed after any exponent …\nGet if multiple consecutive fraction digit separators are …\nGet if digit separators are allowed between fraction …\nGet if a digit separator is allowed before any fraction …\nGet if a digit separator is allowed after any fraction …\nGet if multiple consecutive integer digit separators are …\nGet if digit separators are allowed between integer digits.\nGet if a digit separator is allowed before any integer …\nGet if a digit separator is allowed after any integer …\nGet the radix for mantissa digits.\nGet if exponent notation is not allowed.\nGet if an exponent without fraction is not allowed.\nGet if leading zeros before a float are not allowed.\nGet if leading zeros before an integer are not allowed.\nGet if a positive sign before the exponent is not allowed.\nGet if a positive sign before the mantissa is not allowed.\nGet if special (non-finite) values are not allowed.\nGet if digits are required after the exponent character.\nGet if exponent notation is required.\nGet if a sign symbol before the exponent is required.\nGet if digits are required after the decimal point.\nGet if digits are required before the decimal point.\nGet if at least 1 significant digit is required.\nGet if a sign symbol before the mantissa is required.\nGet if any digit separators are allowed in special …\nCreate number format for standard, hexadecimal number.\nCalls <code>U::from(self)</code>.\nDetermine if the base prefix character is valid.\nDetermine if the base suffix character is valid.\nDetermine if the digit separator is valid. Digit …\nDetermine if the provided exponent flags are valid.\nDetermine if all of the “punctuation” characters for …\nDetermine if all of the “punctuation” characters are …\nDetermine if the radix is valid.\nExtract the mantissa radix from the format packed struct.\nSet the radix for mantissa digits.\nCreate new NumberFormatBuilder with default arguments.\nCreate number format for standard, octal number.\nAlias for mantissa radix.\nExtract a generic radix from the format and bitflags.\nRe-create builder from format.\nTrait to simplify creation of a <code>Bytes</code> object.\nSlice iterator that stores the original length of the …\nIterator over a contiguous block of bytes.\nDetermine if each yielded value is adjacent in memory.\nIf each yielded value is adjacent in memory.\nGet a ptr to the current start of the iterator.\nGet a ptr to the current start of the iterator.\nGet a slice to the current start of the iterator.\nGet a slice to the current start of the iterator.\nCreate <code>Bytes</code> from object.\nCheck if the next element is a given value without case …\nCheck if the next element is a given value without case …\nGet the current number of values returned by the iterator.\nGet the current number of values returned by the iterator.\nGet the current index of the iterator in the slice.\nGet the current index of the iterator in the slice.\nGet iterator over exponent digits.\nCheck if the next element is a given value.\nGet iterator over fraction digits.\nReturns the argument unchanged.\nGet iterator over integer digits.\nCalls <code>U::from(self)</code>.\nGet if the iterator cannot return any more elements.\nDetermine if the iterator is contiguous.\nGet if the buffer underlying the iterator is empty.\nGet if the buffer underlying the iterator is empty. Same …\nGet the total number of elements in the underlying slice.\nGet the total number of elements in the underlying slice.\nCreate new byte object.\nPeek the next value of the iterator, without consuming it.\nCheck if the next element is a given value.\nPeek the next value of the iterator, without checking …\nTry to read a value of a different type from the iterator. …\nTry to read a value of a different type from the iterator. …\nRead a value of a difference type from the iterator. This …\nRead a value of a difference type from the iterator. This …\nSet the current index of the iterator in the slice.\nSet the current index of the iterator in the slice.\nSkip zeros from the start of the iterator\nGet iterator over special floating point values.\nAdvance the internal slice by <code>N</code> elements.\nAdvance the byte by <code>N</code> elements.\nAdvance the internal slice by 1 element.\nAdvance the byte by 1 element.\nMultiply two unsigned, integral values, and return the hi …\nMultiply two unsigned, integral values, and return the hi …\nAn interface for casting between machine scalars.\nType that can be converted to primitive with <code>as</code>.\nMask to determine if a full-carry occurred (1 in bit above …\nExponent portion of a denormal float.\nBias of the exponent.\nBitmask for the exponent, including the hidden bit.\nSize of the exponent.\nFloat information for native float types.\nBitmask for the hidden bit in exponent, which is an …\nPositive infinity as bits.\nIf the number is a signed type.\nDefines a trait that supports integral operations.\nBitmask for the mantissa (fraction), excluding the hidden …\nSize of the significand (mantissa) without hidden bit.\nMaximum exponent value in float.\nPositive infinity as bits.\nNumerical type trait.\nPrimitive type trait (which all have static lifetimes).\nBitmask for the sign bit.\nDefines a trait that supports signed integral operations.\nUnsigned type of the same size.\nDefines a trait that supports unsigned integral operations.\nAllows the high-level conversion of generic types as if <code>as</code> …\nCreates a number from another value that can be converted …\nGet the number of bits in a value.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling of the quotient from integer division.\nGet the fast ceiling modulus from integer division. Not …\nGet exponent component from the float.\nReturns true if the float is a denormal.\nReturns true if the least-significant bit is even.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is infinite.\nReturns true if the float is NaN.\nReturns true if the least-significant bit is odd.\nReturns true if the float’s least-significant mantissa …\nReturns true if the float is a NaN or Infinite.\nGet mantissa (significand) component from float.\nGet the max of two finite numbers.\nGet the min of two finite numbers.\nGet next greater float.\nGet next greater float for a positive float. Value must be …\nGet previous greater float, such that …\nGet previous greater float for a positive float. Value …\nRound a positive number to even.\nShared trait for all parser options.\nShared trait for all writer options.\nGet an upper bound on the buffer size.\nDetermine if the options are valid.\nDetermine if the options are valid.\nContains the error value\nContains the success value\nA specialized Result type for lexical operations.\nCalculate the maximum number of digits that can be …\nCalculate the maximum number of digits that can always be …\nCalculate the number of digits that can be processed …")