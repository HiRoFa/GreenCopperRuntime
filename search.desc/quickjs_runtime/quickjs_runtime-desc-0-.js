searchState.loadedDescShard("quickjs_runtime", 0, "quickjs_runtime\ncontains the QuickJsRuntimeBuilder which may be used to …\ncontains the QuickJsRuntimeFacade\ncontains engine features like console, setTimeout, …\nThis contains abstract traits and structs for use with …\nlow level contains utils for calling the quickjs api\nJSValueRef is a wrapper for quickjs’s JSValue. it …\nutils for implementing proxy classes which can be used to …\nthe EsRuntimeBuilder is used to init an EsRuntime\nbuild an EsRuntime\nReturns the argument unchanged.\nset a Garbage Collection interval, this will start a timer …\nnumber of allocations before gc is run\nCalls <code>U::from(self)</code>.\nset a max stack size\nset max memory the runtime may use\nadd a module loader which can load native functions and …\ninit a new EsRuntimeBuilder\nadd a script loaders which will be used to load modules …\nadd a ScriptPreProcessor which will be called for all …\nadd an interrupt handler, this will be called several …\nEsRuntime is the main public struct representing a …\nadd a task the the “helper” thread pool\nadd an async task the the “helper” thread pool\nthis is how you add a closure to the worker thread which …\nthis is how you add a closure to the worker thread which …\nthis can be used to run a function in the event_queue …\nthis can be used to run a function in the event_queue …\ncreate a new context besides the always existing …\ndrop a context which was created earlier with a call to …\nEvaluate a script asynchronously\nevaluate a module, you need this if you want to compile a …\nevaluate a module synchronously, you need this if you want …\nEvaluate a script and return the result synchronously\nthis is how you add a closure to the worker thread which …\nthis is how you add a closure to the worker thread which …\nReturns the argument unchanged.\nReturns the argument unchanged.\nrun the garbage collector asynchronously\nrun the garbage collector and wait for it to be done\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ninvoke a function in the engine asynchronously N.B. …\ninvoke a function in the engine and get the result …\nadd a job to the eventloop which will execute async(placed …\nadd a job to the eventloop which will be executed async …\nadd a job to the eventloop which will be executed …\nadd a job for a specific realm without expecting a result. …\nadd a job to the eventloop which will execute sync(placed …\nadd a job to the eventloop (placed at end of eventloop) …\nget memory usage for this runtime\nthis adds a rust function to JavaScript, it is added for …\nthe console feature enables the script to use various …\nprovides the setImmediate methods for the runtime\nprovides the setImmediate methods for the runtime\nthe JsValueType represents the type of value for a JSValue\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nadd a task the the “helper” thread pool\nadd an async task the the “helper” thread pool\ncreate a new promise with a producer and a mapper the …\nUtils to compile script to bytecode and run script from …\nUtils for working with Date objects\nutils for getting and reporting exceptions\nutils to create and invoke functions\nSafety\nSafety\nCalculate a runtimes memory usage\nget the current filename\nget the current filename\nutils for the iterator protocol\nserialize and stringify JavaScript objects\nMap utils, these methods can be used to manage Map objects …\nutils for working with ES6 Modules\nUtils for working with objects\nSafety\nSet utils, these methods can be used to manage Set objects …\nthis module is a work in progress and is currently used by …\nSafety\nCreate a new Array\nSafety\nGet a single element from an array\nGet the length of an Array\nGet the length of an Array\nSafety\nCheck whether an object is an array\nSafety\nSet a single element in an array\nReturns the argument unchanged.\nSafety\nCalls <code>U::from(self)</code>.\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\ncompile a script, will result in a JSValueRef with tag …\nread a compiled function from bytecode, see to_bytecode …\nrun a compiled function, see compile for an example\nwrite a function to bytecode\nget the timestamp from a Date object\nget the timestamp from a Date object\ncheck if a JSValueRef is an instance of Date\ncheck if a JSValueRef is an instance of Date\ncreate a new instance of a Date object\ncreate a new instance of a Date object\nset the timestamp for a Date object\nset the timestamp for a Date object\nconvert an instance of Error to JsError\nGet the last exception from the runtime, and if present, …\nSee if a JSValueRef is an Error object\nSee if a JSValueRef is an Error object\nCreate a new Error object\nThrow an error and get an Exception JSValue to return from …\ncall a constructor (instantiate an Object)\ncall a constructor (instantiate an Object)\ncall a function\ncall a function\ncall a function\ncall a function\ncall an objects to_String method or convert a value to …\ncall an objects to_String method or convert a value to …\nSafety\nsee if an Object is an instance of Function and is a …\nsee if an Object is an instance of Function and is a …\nsee if an Object is an instance of Function\nsee if an Object is an instance of Function\ncreate a new Function which is backed by a closure\ncreate a new Function which is backed by a closure\ncreate a new Function object which calls a native method\ncreate a new Function object which calls a native method …\ncreate a new Function object which calls a native method …\ncreate a new Function object which calls a native method\nparse a function body and its arg_names into a JSValueRef …\nset an interrupt handler for the runtime\niterate over an object conforming to the iterator protocol\nParse a JSON string into an Object\nParse a JSON string into an Object please note that …\nSafety\nStringify an Object in script\nremove all entries from a map\nremove all entries from a map\ndelete a value from a map by key\ndelete a value from a map by key\niterate over all entries of a map\niterate over all entries of a map\nget a value from a map by key\nget a value from a map by key\ncheck whether a Map has a value for a key\ncheck whether a Map has a value for a key\nsee if a JSValueRef is an instance of Map\nsee if a JSValueRef is an instance of Map\niterate over all keys of a map\niterate over all keys of a map\ncreate new instance of Map\ncreate new instance of Map\nset a key/value pair in a Map\nset a key/value pair in a Map\nget the number of entries in a map\nget the number of entries in a map\niterate over all values of a map\niterate over all values of a map\nset an export in a JSModuleDef, this should be called …\ncompile a module, used for module loading\ndetect if a script is module (contains import or export …\nget the name of an JSModuleDef struct\ncreate new Module (JSModuleDef struct) which can be …\nset an export in a JSModuleDef, this should be called …\nconstruct a new instance of a constructor\ncreate a new simple object, e.g. <code>let obj = {};</code>\ncreate a new simple object, e.g. <code>let obj = {};</code>\ndefine a getter/setter property\ndefine a getter/setter property\nSafety\nget a namespace object this is used to get nested object …\nget the property names of an object\nget the property names of an object\nget a property from an object by name\nget the names of all properties of an object\nget the names of all properties of an object\nget a property from an object by name\nObject.prototypeOf\nSafety\nSafety\nset a property in an object, like <code>obj[propName] = val;</code>\nset a property with specific flags\nset a property with specific flags set_property applies …\nset a property in an object, like <code>obj[propName] = val;</code>\nSafety\nSafety\nSafety\nSafety\nSafety\nSafety\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSafety\ncreate a new Promise you can use this to respond …\nSafety\nSafety\nthis is a wrapper struct for JSPropertyEnum struct in …\nReturns the argument unchanged.\nget a raw ptr to an Atom\nCalls <code>U::from(self)</code>.\ncreate new class id\nadd a value to a Set\nadd a value to the Set\nremove all entries from a Set\nremove all entries from a Set\ndelete a value from a set\ndelete a value from a set\ncheck whether a Set has a value\ncheck whether a Set has a certain value\nsee if a JSValueRef is an instance of Set\nsee if a JSValueRef is an instance of Set\ncreate new instance of Set\ncreate new instance of Set\nget the number of entries in a Set\nget the number of entries in a Set\niterate over all values of a Set\niterate over all values of a Set\ndetach the array buffer and return it, after this the …\ndetach the array buffer and return it, after this the …\nget the underlying ArrayBuffer of a TypedArray\nGet a copy of the underlying array buffer and return it …\nGet a copy of the underlying array buffer and return it …\nget the underlying ArrayBuffer of a TypedArray\ncheck if a ref is an ArrayBuffer\ncheck if a ref is a TypedArray\nthis method creates a new ArrayBuffer which is used as a …\ncreate an array buffer with a copy of the data in a Vec\ncreate an array buffer with a copy of the data in a Vec\nthis method creates a new ArrayBuffer which is used as a …\ncreate a new TypedArray with a buffer, the buffer is …\ncreate a new TypedArray with a buffer, the buffer is …\ncreate a new TypedArray with a buffer, the buffer is …\ncreate a new TypedArray with a buffer, the buffer is …\ncreate a new Promise with a FnOnce producer which will run …\ncreate a new Promise with a Future which will run async …\nevaluate a script\nSafety\nevaluate a Module\nSafety\nReturns the argument unchanged.\nconvert a JSValueFacade into a JSValueAdapter you need …\nGet the last exception from the runtime, and if present, …\nGet the last exception from the runtime, and if present, …\nget the id of a QuickJsContext from a JSContext\nCalls <code>U::from(self)</code>.\ninvoke a function by namespace and name\npush an element into an Array\nthrow an internal error to quickjs and create a new ex obj\nthrow an Error in the runtime and init an Exception …\nSafety\nthis is the internal abstract loader which is used to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nrun the garbage collector\nSafety\nhas module is used to check if a loader can provide a …\ninit a module, currently used to init native modules\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nload the Module\nthis method tries to load a module script using the …\nget memory usage for this runtime\nthe normalize methods is used to translate a possible …\nrun pending jobs if avail\nborrow the value but first increment the refcount, this is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nreturn true if the wrapped value represents a JS boolean …\nreturn true if the wrapped value represents a compiled …\nreturn true if the wrapped value represents a JS Exception …\nreturn true if the wrapped value represents a JS F64 value\nreturn true if the wrapped value represents a JS INT value\nreturn true if the wrapped value represents a Module\nreturn true if the wrapped value represents a JS null value\nreturn true if the wrapped value represents a JS Object …\nreturn true if the wrapped value represents a JS String …\nreturn true if the wrapped value represents a JS null value\nNo value.\nNo value.\nThe Proxy struct can be used to create a class in …\nSome value of type <code>T</code>.\nSome value of type <code>T</code>.\nadd a catchall getter and setter to the Proxy class, these …\nadd a constructor for the Proxy class this will enable a …\nindicate the Proxy class should implement the EventTarget …\nEventTarget utils\nadd a finalizer for the Proxy class this will be called …\nReturns the argument unchanged.\nget the canonical classname of a Proxy\nget a proxy by class_name (namespace.ClassName)\nGet the instance id of a proxy instance\nadd a getter and setter to the Proxy class, these will be …\nadd a getter and setter to the Proxy class, these will be …\ninstall the Proxy class in a QuickJsContext, this is …\nCalls <code>U::from(self)</code>.\ncheck if an object is an instance of a Proxy class\nadd a method to the Proxy class, this method will be …\nset the name of the proxy class this will indicate how to …\nset the namespace of the proxy class\nadd a method to the Proxy class, this method will be …\nadd a static getter and setter to the Proxy class\nindicate the Proxy class should implement the EventTarget …\nadd a static getter and setter to the Proxy class\nadd a static method to the Proxy class, this method will …\nadd a static method to the Proxy class, this method will …\ndispatch an Event on an instance of a Proxy class the …\ndispatch an Event on a Proxy class the return value is …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe JsValueFacade is a Send-able representation of a value …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncreate a new promise with a producer which will run async …")