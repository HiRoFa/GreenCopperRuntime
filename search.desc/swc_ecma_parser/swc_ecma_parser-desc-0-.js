searchState.loadedDescShard("swc_ecma_parser", 0, "EcmaScript/TypeScript parser for the rust programming …\nNote: Lexer need access to parser’s context to lex …\nSyntactic context.\nContains the error value\nStandard\nContains the success value\nWhen error occurs, error is emitted and parser returns …\nEcmaScript parser.\nImplementation of Input.\nClone should be cheap if you are parsing typescript …\nThis variant requires the cargo feature <code>typescript</code> to be …\nImplementors should use Rc&lt;RefCell&lt;Vec&gt;&gt;.\nAdd an error which is valid syntax in script mode.\nReturns None if it’s end of input <strong>or</strong> current character …\nTODO(kdy1): Remove this?\nEnable decorators.\nbabel: <code>decorators.decoratorsBeforeExport</code>\n<code>.d.ts</code>\nImplementors can override the method to make it faster.\nThis method modifies [last_pos()] and [cur_pos()].\nSupport function bind expression.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nStage 3.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementors can override the method to make it faster.\nImplementors can override the method to make it faster.\nShould we parse jsx?\nECMAScript lexer.\n<code>start</code> and <code>end</code> can be arbitrary value, but start should be …\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nNote: This is recommended way to parse a file.\nReturns Module if it’s a module and returns Script if it…\nParse a statement but not a declaration.\nParse a statement and maybe a declaration.\n<code>tsParseTypeArguments</code>\nPorted from babel/babylon\nShould we parse typescript?\nTakes items from stream, testing each one with predicate. …\n<code>()</code>\nNote: this struct is 8 bytes.\n‘eval’ and ‘arguments’ are invalid identifier in …\n“implements”, “interface”, “let”, “package”…\nUnexpected token\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSpan of the previous default case\nNote: Lexer need access to parser’s context to lex …\nClone should be cheap if you are parsing typescript …\nImplementors should use Rc&lt;RefCell&lt;Vec&gt;&gt;.\nAdd an error which is valid syntax in script mode.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTake captured tokens\nThe algorithm used to determine whether a regexp can …\nReturns None if it’s end of input <strong>or</strong> current character …\nImplementors can override the method to make it faster.\nThis method modifies [last_pos()] and [cur_pos()].\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nImplementors can override the method to make it faster.\nImplementors can override the method to make it faster.\nTakes items from stream, testing each one with predicate. …\nPorted from babylon/util/identifier.js\nIs this <code>for</code> loop?\nStart of a template literal.\nImplementation of Input.\nReturns None if it’s end of input <strong>or</strong> current character …\nImplementors can override the method to make it faster.\nThis method modifies [last_pos()] and [cur_pos()].\nImplementors can override the method to make it faster.\nImplementors can override the method to make it faster.\nTakes items from stream, testing each one with predicate. …\nImplemented for <code>char</code>.\nTest whether a given character is part of an identifier.\nTest whether a given character code starts an identifier.\nSee …\nSee https://tc39.github.io/ecma262/#sec-line-terminators\nSee https://tc39.github.io/ecma262/#sec-white-space\n<code>+</code>\n‘=&gt;’\n‘@’\nSpec says this might be identifier.\n‘`’\n‘!’\n<code>&amp;</code>\n<code>|</code>\n<code>^</code>\n‘:’\n‘::’\n‘,’\n<code>/</code>\n‘${’\n‘.’\n‘…’\n<code>==</code>\n<code>===</code>\n<code>**</code>\n<code>&gt;</code>\n<code>&gt;=</code>\n‘#’\nKeywords\n‘{’\n<code>[</code>\n‘(’\n<code>&lt;&lt;</code>\n<code>&amp;&amp;</code>\n<code>||</code>\n<code>&lt;</code>\n<code>&lt;=</code>\n<code>--</code>\n<code>%</code>\n<code>*</code>\n<code>!=</code>\n<code>!==</code>\n<code>??</code>\nTODO: Make Num as enum and separate decimal, binary, ..etc\n<code>++</code>\n‘?’\n‘}’\n‘]’\n‘)’\n<code>&gt;&gt;</code>\nRegexp literal.\n‘;’\nString literal. Span of this token contains quote.\n<code>-</code>\n<code>~</code>\nIdentifier, “null”, “true”, “false”.\nSpec says this might be identifier.\n<code>&gt;&gt;&gt;</code>\nThis method is called only in the case of parsing failure.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nHad a line break before this token?\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")