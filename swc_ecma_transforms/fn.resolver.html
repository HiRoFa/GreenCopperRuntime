<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="See Ident for know how does swc manages identifiers."><title>resolver in swc_ecma_transforms - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../static.files/rustdoc-b0742ba02757f159.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="swc_ecma_transforms" data-themes="" data-resource-suffix="" data-rustdoc-version="1.83.0 (90b35a623 2024-11-26)" data-channel="1.83.0" data-search-js="search-f0d225181b97f9a4.js" data-settings-js="settings-805db61a62df4bd2.js" ><script src="../static.files/storage-1d39b6787ed640ff.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-f070b9041d14864c.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-0111fcff984fae8f.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc fn"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../swc_ecma_transforms/index.html">swc_<wbr>ecma_<wbr>transforms</a><span class="version">0.199.27</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">resolver</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#when-to-run" title="When to run">When to run</a></li><li><a href="#what-does-it-do" title="What does it do">What does it do</a></li><li><a href="#panics" title="Panics">Panics</a></li><li><a href="#example" title="Example">Example</a></li><li><a href="#parameters" title="Parameters">Parameters</a><ul><li><a href="#unresolved_mark" title="`unresolved_mark`"><code>unresolved_mark</code></a></li><li><a href="#top_level_mark" title="`top_level_mark`"><code>top_level_mark</code></a></li><li><a href="#typescript" title="`typescript`"><code>typescript</code></a></li></ul></li><li><a href="#faq" title="FAQ">FAQ</a><ul><li><a href="#does-a-pair-jsword-syntaxcontext-always-uniquely-identifiers-a" title="Does a pair `(JsWord, SyntaxContext)` always uniquely identifiers a">Does a pair <code>(JsWord, SyntaxContext)</code> always uniquely identifiers a</a></li></ul></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate swc_<wbr>ecma_<wbr>transforms</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="index.html">swc_ecma_transforms</a></span><h1>Function <span class="fn">resolver</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/swc_ecma_transforms_base/resolver/mod.rs.html#133-137">source</a> </span></div><pre class="rust item-decl"><code>pub fn resolver(
    unresolved_mark: <a class="struct" href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a>,
    top_level_mark: <a class="struct" href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a>,
    typescript: <a class="primitive" href="https://doc.rust-lang.org/1.83.0/std/primitive.bool.html">bool</a>,
) -&gt; impl <a class="trait" href="../swc_ecma_visit/trait.Fold.html" title="trait swc_ecma_visit::Fold">Fold</a> + <a class="trait" href="../swc_ecma_visit/trait.VisitMut.html" title="trait swc_ecma_visit::VisitMut">VisitMut</a> + 'static</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>See <a href="../swc_ecma_ast/ident/struct.Ident.html" title="struct swc_ecma_ast::ident::Ident">Ident</a> for know how does swc manages identifiers.</p>
<h2 id="when-to-run"><a class="doc-anchor" href="#when-to-run">§</a>When to run</h2>
<p>The resolver expects ‘clean’ ast. You can get clean ast by parsing, or by
removing all syntax context in ast nodes.</p>
<h2 id="what-does-it-do"><a class="doc-anchor" href="#what-does-it-do">§</a>What does it do</h2>
<p>Firstly all scopes (fn, block) has it’s own SyntaxContext.
Resolver visits all identifiers in module, and look for binding identifies
in the scope. Those identifiers now have the SyntaxContext of scope (fn,
block). While doing so, resolver tries to resolve normal identifiers (no
hygiene info) as a reference to identifier of scope. If the resolver find
suitable variable, the identifier reference will have same context as the
variable.</p>
<h2 id="panics"><a class="doc-anchor" href="#panics">§</a>Panics</h2>
<p><code>top_level_mark</code> should not be root.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2><div class="example-wrap"><pre class="language-js"><code>let a = 1;
{
    let a = 2;
    use(a);
}
use(a)</code></pre></div>
<p>resolver does</p>
<ol>
<li>
<p>Define <code>a</code> with top level context.</p>
</li>
<li>
<p>Found a block, so visit block with a new syntax context.</p>
</li>
<li>
<p>Defined <code>a</code> with syntax context of the block statement.</p>
</li>
<li>
<p>Found usage of <code>a</code>, and determines that it’s reference to <code>a</code> in the
block. So the reference to <code>a</code> will have same syntax context as <code>a</code> in the
block.</p>
</li>
<li>
<p>Found usage of <code>a</code> (last line), and determines that it’s a
reference to top-level <code>a</code>, and change syntax context of <code>a</code> on last line to
top-level syntax context.</p>
</li>
</ol>
<h2 id="parameters"><a class="doc-anchor" href="#parameters">§</a>Parameters</h2><h3 id="unresolved_mark"><a class="doc-anchor" href="#unresolved_mark">§</a><code>unresolved_mark</code></h3>
<p><a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> applied to unresolved references.</p>
<p>A pass should accept this <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> if it’s going to generate a refernce to
globals like <code>require</code>.</p>
<p>e.g. <code>common_js</code> pass generates calls to <code>require</code>, and this should not
be shadowed by a declaration named <code>require</code> in the same file.
So it uses this value.</p>
<h3 id="top_level_mark"><a class="doc-anchor" href="#top_level_mark">§</a><code>top_level_mark</code></h3>
<p><a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> applied to top-level bindings.</p>
<p><strong>NOTE</strong>: This is <strong>not</strong> globals. This is for top level items declared by
users.</p>
<p>A pass should accept this <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> if it requires user-defined top-level
items.</p>
<p>e.g. <code>jsx</code> pass requires to call <code>React</code> imported by the user.</p>
<div class="example-wrap"><pre class="language-js"><code>import React from &#39;react&#39;;</code></pre></div>
<p>In the code above, <code>React</code> has this <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a>. <code>jsx</code> passes need to
reference this <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a>, so it accpets this.</p>
<p>This <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> should be used for referencing top-level bindings written by
user. If you are going to create a binding, use <code>private_ident</code>
instead.</p>
<p>In other words, <strong>this <a href="../swc_common/syntax_pos/hygiene/struct.Mark.html" title="struct swc_common::syntax_pos::hygiene::Mark">Mark</a> should not be used for determining if a
variable is top-level.</strong> This is simply a configuration of the <code>resolver</code>
pass.</p>
<h3 id="typescript"><a class="doc-anchor" href="#typescript">§</a><code>typescript</code></h3>
<p>Enable this only if you are going to strip types or apply type-aware
passes like decorators pass.</p>
<h2 id="faq"><a class="doc-anchor" href="#faq">§</a>FAQ</h2><h3 id="does-a-pair-jsword-syntaxcontext-always-uniquely-identifiers-a"><a class="doc-anchor" href="#does-a-pair-jsword-syntaxcontext-always-uniquely-identifiers-a">§</a>Does a pair <code>(JsWord, SyntaxContext)</code> always uniquely identifiers a</h3>
<p>variable binding?</p>
<p>Yes, but multiple variables can have the exactly same name.</p>
<p>In the code below,</p>
<div class="example-wrap"><pre class="language-js"><code>var a = 1, a = 2;</code></pre></div>
<p>both of them have the same name, so the <code>(JsWord, SyntaxContext)</code> pair will
be also identical.</p>
</div></details></section></div></main></body></html>